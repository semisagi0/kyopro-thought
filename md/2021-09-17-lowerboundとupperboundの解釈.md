## Lower BoundとUpper Boundの解釈
長さ`N`のソートされている配列`A`に対して、

- `A.lowerBound(x)`を`A[i]>=x`を満たす最小の`i`と定義する。そのような`i`が存在しない場合は`N`と定義する。
- `A.upperBound(x)`を`A[i]>x`を満たす最小の`i`と定義する。そのような`i`が存在しない場合は`N`と定義する。

ところで、配列`A`はソートされているので、

- `A[i]<x`となる`i`の区間。
- `A[i]=x`となる`i`の区間。
- `A[i]>x`となる`i`の区間。

の3つに分割できる。ただし、いずれかの区間が空になることもある。たとえば`[0,1,2,2,2,3,4]`を`x=2`で分割すると次のようになる。

```
    lowerBound  upperBound
        |           |
        v           v
+---+---+---+---+---+---+---+
| 0 | 1 | 2 | 2 | 2 | 3 | 4 |
+---+---+---+---+---+---+---+
0   1   2   3   4   5   6   7

|<----->|<--------->|<----->|
    <2        =2        >2
```

このとき、

- `A.lowerBound(x)`は`<x`の区間と`=x`の区間の境界位置を表し、
- `A.upperBound(x)`は`=x`の区間と`>x`の区間の境界位置を表す。

ただし、境界とは隣接する2要素`A[i]`,`A[i+1]`の間のことを意味し、`A[i]`と`A[i+1]`の境界位置は整数`i+1`を意味する。また、`A[0]`の左側と`A[N-1]`の右側も境界として扱う。それぞれの境界に対応する境界位置は`0`,`N`とする。
このとき、上の例では`A.lowerBound(2)=2`、`A.upperBound(2)=5`となる。

したがって、以下の事実が導かれる。

- `A[i]>=x`を満たす要素の個数は`N - A.lowerBound(x)`である。
- `A[i]<=x`を満たす要素の個数は`A.upperBound(x) - 0`である。
- `A[i]<x`を満たす要素の個数は`A.lowerBound(x) - 0`である。
- `A[i]>x`を満たす要素の個数は`N - A.upperBound(x)`である。
- `x<A[i]<y`を満たす要素の個数は`A.lowerBound(y) - A.upperBound(x)`である。
- `A[i]=x`を満たす要素の個数は`A.upperBound(x) - A.lowerBound(x)`である。

なお、ここでは境界位置`i`と`j`に挟まれる要素の個数が`j - i`であることを用いている。

この考え方は累積和にも応用できる。たとえば`x<A[i]<y`を満たす`A[i]`の総和を求めるには、累積和を`S[i]`として`S[A.lowerBound(y)] - S[A.upperBound(x)]`を計算すればよい。

